"""
This module defines the various kinds of plugins supported by Transformer.

Transformer plugins are just functions that accept certain inputs and have
certain outputs. Different kinds of plugins have different input and output
types. These input and output types are formalized here using Python's
annotation syntax and the typing module.

# Plugin kinds

## OnTask

Kind of "stateless" plugins that operate independently on each task.
The execution of this plugin could be parallelized.

Example: a plugin that injects a header in all requests.

## OnScenario

Kind of plugins that operate on scenarios.

Each scenario is the root of a tree composed of smaller scenarios and tasks
(the leaves of this tree). Therefore, in an OnScenario plugin, you have the
possibility of inspecting the subtree and make decisions based on that.
However, OnScenario plugins will be applied to all scenarios by Transformer,
so you don't need to recursively apply the plugin yourself on all subtrees.
If you do that, the plugin will be applied many times more than necessary.

Example: a plugin that keeps track of how long each scenario runs.

## OnPythonProgram

Kind of plugins that operate on the whole syntax tree.

The input and output of this kind of plugins is the complete, final locustfile
generated by Transformer, represented as a syntax tree.
OnPythonProgram plugins therefore have the most freedom compared to other
plugin kinds, because they can change anything.
Their downside is that manipulating the syntax tree is more complex than the
scenario tree or individual tasks.

Example: a plugin that injects some code in the global scope.
"""
from typing import Sequence, Callable

from transformer import python
from transformer.scenario import Scenario
from transformer.task import Task, Task2


OnTask = Callable[[Task2], Task2]


OnScenario = Callable[[Scenario], Scenario]


OnPythonProgram = Callable[[python.Program], python.Program]


# Historically Transformer has only one kind of plugin, which transformed a
# sequence of Task objects into another such sequence. Operating on a full list
# of tasks (instead of task by task) offered more leeway: a plugin could e.g.
# add a new task, or change only the first task.
# However this OnTaskSequence model is too constraining for some use-cases,
# e.g. when a plugin needs to inject code in the global scope, and having to
# deal with a full, immutable list of tasks in plugins that independently
# operate on each task implies a lot of verbosity and redundancy.
# For these reasons, other plugin kinds were created to offer a more varied
# choice for plugin implementers.
# See https://github.com/zalando-incubator/Transformer/issues/10.
OnTaskSequence = Callable[[Sequence[Task]], Sequence[Task]]
